sshpk
=========

Parse, convert, fingerprint and use SSH keys (both public and private) in pure
node -- no `ssh-keygen` or other external dependencies.

Supports RSA, DSA, ECDSA (nistp-\*) and ED25519 key types, in PEM (PKCS#1, 
PKCS#8) and OpenSSH formats.

This library has been extracted from
[`node-http-signature`](https://github.com/joyent/node-http-signature)
(work by [Mark Cavage](https://github.com/mcavage) and
[Dave Eddy](https://github.com/bahamas10)) and
[`node-ssh-fingerprint`](https://github.com/bahamas10/node-ssh-fingerprint)
(work by Dave Eddy), with additions (including ECDSA support) by
[Alex Wilson](https://github.com/arekinath).

Install
-------

```
npm install sshpk
```

Examples
--------

```js
var sshpk = require('sshpk');

var fs = require('fs');

/* Read in an OpenSSH-format public key */
var keyPub = fs.readFileSync('id_rsa.pub');
var key = sshpk.parseKey(keyPub, 'ssh');

/* Get metadata about the key */
console.log('type => %s', key.type);
console.log('size => %d bits', key.size);
console.log('comment => %s', key.comment);

/* Compute key fingerprints, in new OpenSSH (>6.7) format, and old MD5 */
console.log('fingerprint => %s', key.fingerprint().toString());
console.log('old-style fingerprint => %s', key.fingerprint('md5').toString());
```

Example output:

```
type => rsa
size => 2048 bits
comment => foo@foo.com
fingerprint => SHA256:PYC9kPVC6J873CSIbfp0LwYeczP/W4ffObNCuDJ1u5w
old-style fingerprint => a0:c8:ad:6c:32:9a:32:fa:59:cc:a9:8c:0a:0d:6e:bd
```

More examples: converting between formats:

```js
/* Read in a PEM public key */
var keyPem = fs.readFileSync('id_rsa.pem');
var key = sshpk.parseKey(keyPem, 'pem');

/* Convert to PEM PKCS#8 public key format */
var pemBuf = key.toBuffer('pkcs8');

/* Convert to SSH public key format (and return as a string) */
var sshKey = key.toString('ssh');
```

Signing and verifying:

```js
/* Read in an OpenSSH/PEM *private* key */
var keyPriv = fs.readFileSync('id_ecdsa');
var key = sshpk.parsePrivateKey(keyPriv, 'pem');

var data = 'some data';

/* Sign some data with the key */
var s = key.createSign('sha1');
s.update(data);
var signature = s.sign();

/* Now load the public key (could also use just key.toPublic()) */
var keyPub = fs.readFileSync('id_ecdsa.pub');
key = sshpk.parseKey(keyPub, 'ssh');

/* Make a crypto.Verifier with this key */
var v = key.createVerify('sha1');
v.update(data);
var valid = v.verify(signature);
/* => true! */
```

Matching fingerprints with keys:

```js
var fp = sshpk.parseFingerprint('SHA256:PYC9kPVC6J873CSIbfp0LwYeczP/W4ffObNCuDJ1u5w');

var keys = [sshpk.parseKey(...), sshpk.parseKey(...), ...];

keys.forEach(function (key) {
	if (fp.matches(key))
		console.log('found it!');
});
```

Usage
-----

## Public keys

### `parseKey(data[, format = 'auto'[, options]])`

Parses a key from a given data format and returns a new `Key` object.

Parameters

- `data` -- Either a Buffer or String, containing the key
- `format` -- String name of format to use, valid options are:
  - `auto`: choose automatically from all below
  - `pem`: supports both PKCS#1 and PKCS#8
  - `ssh`: standard OpenSSH format,
  - `pkcs1`, `pkcs8`: variants of `pem`
  - `rfc4253`: raw OpenSSH wire format
  - `openssh`: new post-OpenSSH 6.5 internal format, produced by 
               `ssh-keygen -o`
  - `dnssec`: `.key` file format output by `dnssec-keygen` etc
  - `putty`: the PuTTY `.ppk` file format (supports truncated variant without
             all the lines from `Private-Lines:` onwards)
- `options` -- Optional Object, extra options, with keys:
  - `filename` -- Optional String, name for the key being parsed 
                  (eg. the filename that was opened). Used to generate
                  Error messages
  - `passphrase` -- Optional String, encryption passphrase used to decrypt an
                    encrypted PEM file

### `Key.isKey(obj)`

Returns `true` if the given object is a valid `Key` object created by a version
of `sshpk` compatible with this one.

Parameters

- `obj` -- Object to identify

### `Key#type`

String, the type of key. Valid options are `rsa`, `dsa`, `ecdsa`.

### `Key#size`

Integer, "size" of the key in bits. For RSA/DSA this is the size of the modulus;
for ECDSA this is the bit size of the curve in use.

### `Key#comment`

Optional string, a key comment used by some formats (eg the `ssh` format).

### `Key#curve`

Only present if `this.type === 'ecdsa'`, string containing the name of the
named curve used with this key. Possible values include `nistp256`, `nistp384`
and `nistp521`.

### `Key#toBuffer([format = 'ssh'])`

Convert the key into a given data format and return the serialized key as
a Buffer.

Parameters

- `format` -- String name of format to use, for valid options see `parseKey()`

### `Key#toString([format = 'ssh])`

Same as `this.toBuffer(format).toString()`.

### `Key#fingerprint([algorithm = 'sha256'[, hashType = 'ssh']])`

Creates a new `Fingerprint` object representing this Key's fingerprint.

Parameters

- `algorithm` -- String name of hash algorithm to use, valid options are `md5`,
                 `sha1`, `sha256`, `sha384`, `sha512`
- `hashType` -- String name of fingerprint hash type to use, valid options are
                `ssh` (the type of fingerprint used by OpenSSH, e.g. in
                `ssh-keygen`), `spki` (used by HPKP, some OpenSSL applications)

### `Key#createVerify([hashAlgorithm])`

Creates a `crypto.Verifier` specialized to use this Key (and the correct public
key algorithm to match it). The returned Verifier has the same API as a regular
one, except that the `verify()` function takes only the target signature as an
argument.

Parameters

- `hashAlgorithm` -- optional String name of hash algorithm to use, any
                     supported by OpenSSL are valid, usually including
                     `sha1`, `sha256`.

`v.verify(signature[, format])` Parameters

- `signature` -- either a Signature object, or a Buffer or String
- `format` -- optional String, name of format to interpret given String with.
              Not valid if `signature` is a Signature or Buffer.

### `Key#createDiffieHellman()`
### `Key#createDH()`

Creates a Diffie-Hellman key exchange object initialized with this key and all
necessary parameters. This has the same API as a `crypto.DiffieHellman`
instance, except that functions take `Key` and `PrivateKey` objects as
arguments, and return them where indicated for.

This is only valid for keys belonging to a cryptosystem that supports DHE
or a close analogue (i.e. `dsa`, `ecdsa` and `curve25519` keys). An attempt
to call this function on other keys will yield an `Error`.

## Private keys

### `parsePrivateKey(data[, format = 'auto'[, options]])`

Parses a private key from a given data format and returns a new
`PrivateKey` object.

Parameters

- `data` -- Either a Buffer or String, containing the key
- `format` -- String name of format to use, valid options are:
  - `auto`: choose automatically from all below
  - `pem`: supports both PKCS#1 and PKCS#8
  - `ssh`, `openssh`: new post-OpenSSH 6.5 internal format, produced by
                      `ssh-keygen -o`
  - `pkcs1`, `pkcs8`: variants of `pem`
  - `rfc4253`: raw OpenSSH wire format
  - `dnssec`: `.private` format output by `dnssec-keygen` etc.
- `options` -- Optional Object, extra options, with keys:
  - `filename` -- Optional String, name for the key being parsed
                  (eg. the filename that was opened). Used to generate
                  Error messages
  - `passphrase` -- Optional String, encryption passphrase used to decrypt an
                    encrypted PEM file

### `generatePrivateKey(type[, options])`

Generates a new private key of a certain key type, from random data.

Parameters

- `type` -- String, type of key to generate. Currently supported are `'ecdsa'`
            and `'ed25519'`
- `options` -- optional Object, with keys:
  - `curve` -- optional String, for `'ecdsa'` keys, specifies the curve to use.
               If ECDSA is specified and this option is not given, defaults to
               using `'nistp256'`.

### `PrivateKey.isPrivateKey(obj)`

Returns `true` if the given object is a valid `PrivateKey` object created by a
version of `sshpk` compatible with this one.

Parameters

- `obj` -- Object to identify

### `PrivateKey#type`

String, the type of key. Valid options are `rsa`, `dsa`, `ecdsa`.

### `PrivateKey#size`

Integer, "size" of the key in bits. For RSA/DSA this is the size of the modulus;
for ECDSA this is the bit size of the curve in use.

### `PrivateKey#curve`

Only present if `this.type === 'ecdsa'`, string containing the name of the
named curve used with this key. Possible values include `nistp256`, `nistp384`
and `nistp521`.

### `PrivateKey#toBuffer([format = 'pkcs1'])`

Convert the key into a given data format and return the serialized key as
a Buffer.

Parameters

- `format` -- String name of format to use, valid options are listed under 
              `parsePrivateKey`. Note that ED25519 keys default to `openssh`
              format instead (as they have no `pkcs1` representation).

### `PrivateKey#toString([format = 'pkcs1'])`

Same as `this.toBuffer(format).toString()`.

### `PrivateKey#toPublic()`

Extract just the public part of this private key, and return it as a `Key`
object.

### `PrivateKey#fingerprint([algorithm = 'sha256'])`

Same as `this.toPublic().fingerprint()`.

### `PrivateKey#createVerify([hashAlgorithm])`

Same as `this.toPublic().createVerify()`.

### `PrivateKey#createSign([hashAlgorithm])`

Creates a `crypto.Sign` specialized to use this PrivateKey (and the correct
key algorithm to match it). The returned Signer has the same API as a regular
one, except that the `sign()` function takes no arguments, and returns a
`Signature` object.

Parameters

- `hashAlgorithm` -- optional String name of hash algorithm to use, any
                     supported by OpenSSL are valid, usually including
                     `sha1`, `sha256`.

`v.sign()` Parameters

- none

### `PrivateKey#derive(newType)`

Derives a related key of type `newType` from this key. Currently this is
only supported to change between `ed25519` and `curve25519` keys which are
stored with the same private key (but usually distinct public keys in order
to avoid degenerate keys that lead to a weak Diffie-Hellman exchange).

Parameters

- `newType` -- String, type of key to derive, either `ed25519` or `curve25519`

## Fingerprints

### `parseFingerprint(fingerprint[, options])`

Pre-parses a fingerprint, creating a `Fingerprint` object that can be used to
quickly locate a key by using the `Fingerprint#matches` function.

Parameters

- `fingerprint` -- String, the fingerprint value, in any supported format
- `options` -- Optional Object, with properties:
  - `algorithms` -- Array of strings, names of hash algorithms to limit
                support to. If `fingerprint` uses a hash algorithm not on
                this list, throws `InvalidAlgorithmError`.
  - `hashType` -- String, the type of hash the fingerprint uses, either `ssh`
                  or `spki` (normally auto-detected based on the format, but
                  can be overridden)
  - `type` -- String, the entity this fingerprint identifies, either `key` or
              `certificate`

### `Fingerprint.isFingerprint(obj)`

Returns `true` if the given object is a valid `Fingerprint` object created by a
version of `sshpk` compatible with this one.

Parameters

- `obj` -- Object to identify

### `Fingerprint#toString([format])`

Returns a fingerprint as a string, in the given format.

Parameters

- `format` -- Optional String, format to use, valid options are `hex` and
              `base64`. If this `Fingerprint` uses the `md5` algorithm, the
              default format is `hex`. Otherwise, the default is `base64`.

### `Fingerprint#matches(keyOrCertificate)`

Verifies whether or not this `Fingerprint` matches a given `Key` or
`Certificate`. This function uses double-hashing to avoid leaking timing
information. Returns a boolean.

Note that a `Key`-type Fingerprint will always return `false` if asked to match
a `Certificate` and vice versa.

Parameters

- `keyOrCertificate` -- a `Key` object or `Certificate` object, the entity to
                        match this fingerprint against

## Signatures

### `parseSignature(signature, algorithm, format)`

Parses a signature in a given format, creating a `Signature` object. Useful
for converting between the SSH and ASN.1 (PKCS/OpenSSL) signature formats, and
also returned as output from `PrivateKey#createSign().sign()`.

A Signature object can also be passed to a verifier produced by
`Key#createVerify()` and it will automatically be converted internally into the
correct format for verification.

Parameters

- `signature` -- a Buffer (binary) or String (base64), data of the actual
                 signature in the given format
- `algorithm` -- a String, name of the algorithm to be used, possible values
                 are `rsa`, `dsa`, `ecdsa`
- `format` -- a String, either `asn1` or `ssh`

### `Signature.isSignature(obj)`

Returns `true` if the given object is a valid `Signature` object created by a
version of `sshpk` compatible with this one.

Parameters

- `obj` -- Object to identify

### `Signature#toBuffer([format = 'asn1'])`

Converts a Signature to the given format and returns it as a Buffer.

Parameters

- `format` -- a String, either `asn1` or `ssh`

### `Signature#toString([format = 'asn1'])`

Same as `this.toBuffer(format).toString('base64')`.

## Certificates

`sshpk` includes basic support for parsing certificates in X.509 (PEM) format
and the OpenSSH certificate format. This feature is intended to be used mainly
to access basic metadata about certificates, extract public keys from them, and
also to generate simple self-signed certificates from an existing key.

Notably, there is no implementation of CA chain-of-trust verification, and only
very minimal support for key usage restrictions. Please do the security world
a favour, and DO NOT use this code for certificate verification in the
traditional X.509 CA chain style.

### `parseCertificate(data, format)`

Parameters

 - `data` -- a Buffer or String
 - `format` -- a String, format to use, one of `'openssh'`, `'pem'` (X.509 in a
               PEM wrapper), or `'x509'` (raw DER encoded)

### `createSelfSignedCertificate(subject, privateKey[, options])`

Parameters

 - `subject` -- an Identity, the subject of the certificate
 - `privateKey` -- a PrivateKey, the key of the subject: will be used both to be
                   placed in the certificate and also to sign it (since this is
                   a self-signed certificate)
 - `options` -- optional Object, with keys:
   - `lifetime` -- optional Number, lifetime of the certificate from now in
                   seconds
   - `validFrom`, `validUntil` -- optional Dates, beginning and end of
                                  certificate validity period. If given
                                  `lifetime` will be ignored
   - `serial` -- optional Buffer, the serial number of the certificate
   - `purposes` -- optional Array of String, X.509 key usage restrictions

### `createCertificate(subject, key, issuer, issuerKey[, options])`

Parameters

 - `subject` -- an Identity, the subject of the certificate
 - `key` -- a Key, the public key of the subject
 - `issuer` -- an Identity, the issuer of the certificate who will sign it
 - `issuerKey` -- a PrivateKey, the issuer's private key for signing
 - `options` -- optional Object, with keys:
   - `lifetime` -- optional Number, lifetime of the certificate from now in
                   seconds
   - `validFrom`, `validUntil` -- optional Dates, beginning and end of
                                  certificate validity period. If given
                                  `lifetime` will be ignored
   - `serial` -- optional Buffer, the serial number of the certificate
   - `purposes` -- optional Array of String, X.509 key usage restrictions

### `Certificate#subjects`

Array of `Identity` instances describing the subject of this certificate.

### `Certificate#issuer`

The `Identity` of the Certificate's issuer (signer).

### `Certificate#subjectKey`

The public key of the subject of the certificate, as a `Key` instance.

### `Certificate#issuerKey`

The public key of th4Z SMۛiHGBƸyfO t߃r"v"7܈?,MV2WT5ԧpjq$r8a.M!&8.bm[༕޽]M?O$PtRҧK3CzO+e80|u=D翝[p-t&Z	LtDފJρ@nxRP#sn=T:bjHjc'd?FN%RjNp3H*^J;Ṷ%+X9DwWYIe;;;mkzU#3PY1)IkV3gؚ@)fv(1HXmr=p ץFQof=fw*6d&>`À+*C]cn(LS>|s6p
PD2&U9Hj旸А8mPZV4C΢Kw4˓&9lY/u/Qwb`1"؈`xpWr{5AۭO;hB<6BpH#8pna &{O@+	8YJNY0%``K҂_JGt%KTpF #.>JQg\SF+*Fj[(V\PDI*j88,N$ XH~l2lؼ
N *NmePqB~KZw(+=\(WVfX&}$M>hEblq~)MX%DnoR%MM*,bw;W~^cC2_/)%ɼG(\cց> X݈=\ȥkDfuW^0Q_OYqUnMe,lc
#Og|c_?G"f5SڝewBN4P"~M..$3{&[]h	h,n6`5ycUB$̸wZ]EBGeG.BYÃ(8ߓPZ	:~҅m1o(>05hk0wrȟNNJmW7$H'Ni7(^h3K1~B jX; pgNg#V=
6<)HVG}o	GeA..[xXtt$Qk>H'-2SO7iLP߁Q=Rŝ7/s5>yA :qioBdA<-%յߋ|4l	MD~ҨpL9k/T\P08L4Gcw@m!n8D|^ h!ԕ|eSޫ6$b!_:*^u<HMż^707˥܋ec.MJ&m~b_?(1~7}8#!t>9+%w?Sy/İw^bv2ԹMJ8|Pvz_^xO+2P#S^2u̬Z_T]Gڭ/Hle'!G>%2iiUU`Dŉ^#S9#\-' {M^nG2/.1Ǉ-{s}\y aے㵭00g)}FӐ;ۇS3Ml]!RgWezT:kuFk~7|WU[seoo}YPn,ڢ/~Fhxol+sxCyg$0:ᕫ*kC7͕l`2i鎨;ktr֋:E\lѮ. NaH=Q #j &P;_xD>qoM0'
)l+=đ0j)`
6XWwduSًKEuYt^wTm8c)\j޵rQ1B!4:-~⃤o^ mg`#C	/:xe] 6"<IJ7I|?&ޙyL2_ʆ`3]3\[h39~9'u1m.L^e{@lN4J:p([m;-
u_9tXoBC!;ݨǚ7p?چ/f|"'o:v5xVN5#LT/,wZn2=n+7{X^Vl09840^;_y\X¥lbAO4WJJえACpifK}#G`m鑯#}*sa6p.Em{kaҁ8L]fQZLH)V0Tv"2!^+J:Xu!	u҂`rOU: jz͒PY7GU˰DQ[*&e>z?=aOT?4\|4yK >֕;./%"`՝SUx@{ub_*31Se--ՙXV$.pUL ղ]U/V`S91D#\vY(XZ.ԂґwwM\̷|T|}\Ư +`K%ys;2S  ¸G?W`@hMzAOjɔ4{Ueu+1	<Oxu-doXu` %b@p+׸+G+<\=*{`v[~Ə{1}ɨK'#dZнc])2Gj`}֨ݍS/[*PZOhJ1=uL/I2V k`4|M%<z@@)jѐPNgKZ\l~rx8^6/\)䶻_baWG<QF#	^nbZ+YэzZ'T*Fi@GCf34enDQTOH=r9K.޶g?,;nP&Icrj&&kuZ@o-2vqq)Qs޽R %%OdИI$땇psܑOl}pJF<c0iQI; bAG`h~t*ej)O)7Iǿ2X}ѩ]dC77o#m\zI."
։E3?a_^I}D~]Kps`4Rz$?՘ZpOiۻi4wg<a(f;sѐC;oBkjҝE]]Z2hp
LzI->ICD$ZWu[&1ж)S QD'PӪxA]mA'̂$#5zHe{5p7?h=ZJ;-ȩau,,/F0g
>Xr)DjRTzJA+Λq|0)?,L%ʍ |{^W3QS6yV`T!]|2~}R1AˍPO?,pVY	))Jx?
}GZOAvi(QH_أ^FTt`wjW+sO?5G.iKQkz}z(Pߚ:PzV"xYL<?	 Hv;;ʄrxїSr-I9(㍍ZFLdZɰKAԽd Mg2^'̿:
Ie&
1fAP젃c_6RʓئgG 6y<|`QsWq	8gG/c;|%ru/h]Yyށ"W3HzKuT=Ie3dqyqڑX7M|liڮq櫑xzOǢ2ˁ?|3
¦I*~NϔN!.HC[RVu| JP<!!ơ=S}@lk|M=>`e6)a!bYqȰҪLBb:cjik`j/3j¬d3ԍJ\a۶<JRLX	%]%.HaӳG/ʼj	6֓a%7Ah N>9eL£Zd(hwO{ó_|N%f~Z1WR1~xG㞖[otX`tY`'9s0᭼cjL4Hr)\Q5T+eSlc7|	]'4C*= Qe04b	enQel&bZ_!	ψq/|$UJ)/a_Yn+]f:PM3C)bd:xkr³\	Y׭(/c9"L'+'
h*荗vH)VNqtyPI>!Un1xREGiBCڜ0k>Nn/
OšFtyzs1^Zu'b]viN3,&UMPc"6Q6p*t7ZJǦhl8?ڜ$Wx0]$)ʻF7ݕ{DCp<d_4\t	F(ƪiRGK7$GӄX/M"s<r:aYKN105H,ݮJa	/>UwBYO:'^OS!(^g(*p{L`c;2'n[xH~&=~tZx֨t=[}MB-.vQ/ۼwvV2ƒֲh~Ȝs)w|8߁RVWTȩC/>~+N.^D=B}SX+➢eehD='%O9nƵB_ ׁm!@gp _Jĸb?))khٵMPkb\RL`LE%Qn ^zKh]Z
bhVaov`UK~ZE=dQA͋W
B^K/ٓ"V 1G&c/tY+A+5{",w}&LkFZ6F 
Y[veWw&Şr%$G`0k!xVmޢf<
iٌql-[eh
ǉ%6x1<J.7^\e4QebDpZC5/A`<NH`dquIv9Rc<H{Q~*5r8xfR(5R4\A9R\*ƫFUm$~2}"̈eR<:2|V#)OZa1J
;hsA&hqc@Qz3ۉ";fǩW2!sJ
=)c0<
2YLQ3[IV륰5p^E jrHkP91ntTU^$.^`%D<)i8"@9δ"tg$q8YVogaC(yY%\f:DH!TOGC~ `gUąCz(KTjGi6:c5	.<r<l߅R2³gf>߃P\_{LɊQs&peS)#DzN!%Q_0ka4!kA<lbzʼNłE0Cx)cԎ3K[;Iz=NrFI6gW\j$iQB%2e,Q`ӓttk\u&_rzԯT<7Dh*ƪ<
!"7mr\V.H'urwXqtkK&S&p_*;lC%Qyya#@ b
ck-2?,9(vlxvB=WojVW24=%mqv?h=Rpu,fw>9
ڤ9A Iϳ`$4^N%J,lgђqM]J?A,})B𷡦8$F4gy9ZQ2)izthZNd'tS 1nr= SmOstnO@z*<՞V-gN N{*".~\';N#ΙŲ#0w8$SL@y%hvU:w$.o09 (9G=sl[p3>ެt SZDMA;>Q$3Ϡ]V76 [ɧ9CQ+[nwgBqWP~z,Zv䚜tDHG#@WF9.JCU!}RK<*]\"[{%bCzRr30;P'ZC]Gn._fUxkOγ`'ܦ}8knhɿHq=*˗(<2{S-{y-qmQ^)#(]0Z0ĊGKNݐ1+"3lZ.?H&	Ff>CՆ͙l$137I!H5f+XI6,֒ᷣ<
#-I^Ewkۄ{|doM5]h}6PQ^r{6~A%M*w"qڱE3j݄8iNՐ0ůgnn}2ᦆkc; #=^ZV?==Y.zj`|OU}'RA&Y²?lxXsfx:0e}|X2"RRh[ڃ
CIrZ2\L	7iLR"{BvdOrmqnʈ6J~6{C%IUUWĭo,x<=o?v1٪Xդ[<"n3kI20XKwZQVov߇~Y,FzN6$O8AC!L@5Ay|1=x,&W_!Tn¼]͉C{MBUn\Ggd7td$GOHFAstG'x_&mKz(pU,5_~?YI\0;/rY	q)CX 23s>|3.*pnfudV'ru3˽|%P9cLͱDNmq
}K	Wi5mw۰N*QM93r bCDXMx{)HYh
-0ZÉL!/>t
n9'?Say9='נxA>@H57!x{|)up'ͤC|Ea!c2`~f]+5pZs{2EE}iIu<
CqM<GFUpgr*5FK1-сna"WXkr@ t˻1ST@&>:BwQƸ+N]w"