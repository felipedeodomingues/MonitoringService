/*
 * moleculer
 * Copyright (c) 2018 MoleculerJS (https://github.com/moleculerjs/moleculer)
 * MIT Licensed
 */

"use strict";

const Promise = require("bluebird");
const _ = require("lodash");

const P = require("./packets");
const { Packet } = require("./packets");
const E = require("./errors");

const { Transform } = require("stream");

/**
 * Transit class
 *
 * @class Transit
 */
class Transit {

	/**
	 * Create an instance of Transit.
	 *
	 * @param {ServiceBroker} Broker instance
	 * @param {Transporter} Transporter instance
	 * @param {Object?} opts
	 *
	 * @memberof Transit
	 */
	constructor(broker, transporter, opts) {
		this.broker = broker;
		this.logger = broker.getLogger("transit");
		this.nodeID = broker.nodeID;
		this.tx = transporter;
		this.opts = opts;

		this.pendingRequests = new Map();
		this.pendingReqStreams = new Map();
		this.pendingResStreams = new Map();

		this.stat = {
			packets: {
				sent: {
					count: 0,
					bytes: 0
				},
				received: {
					count: 0,
					bytes: 0
				}
			}
		};

		this.connected = false;
		this.disconnecting = false;
		this.isReady = false;

		if (this.tx) {
			this.tx.init(this, this.messageHandler.bind(this), this.afterConnect.bind(this));
		}

		this.__connectResolve = null;
	}

	/**
	 * It will be called after transporter connected or reconnected.
	 *
	 * @param {any} wasReconnect
	 * @returns {Promise}
	 *
	 * @memberof Transit
	 */
	afterConnect(wasReconnect) {
		return Promise.resolve()

			.then(() => {
				if (!wasReconnect)
					return this.makeSubscriptions();
			})

			.then(() => this.discoverNodes())
			.delay(500) // Waiting for incoming INFO packets

			.then(() => {
				this.connected = true;

				this.broker.broadcastLocal("$transporter.connected");

				if (this.__connectResolve) {
					this.__connectResolve();
					this.__connectResolve = null;
				}

				return null;
			});
	}

	/**
	 * Connect with transporter. If failed, try again after 5 sec.
	 *
	 * @memberof Transit
	 */
	connect() {
		this.logger.info("Connecting to the transporter...");
		return new Promise(resolve => {
			this.__connectResolve = resolve;

			const doConnect = () => {
				let reconnectStarted = false;
				const errorHandler = (err) => {
					if (this.disconnecting) return;
					if (reconnectStarted) return;

					this.logger.warn("Connection is failed.", err && err.message || "Unknown error");
					this.logger.debug(err);

					if (this.opts.disableReconnect) {
						return;
					}

					reconnectStarted = true;

					setTimeout(() => {
						this.logger.info("Reconnecting...");
						doConnect();
					}, 5 * 1000);
				};
				/* istanbul ignore next */
				this.tx.connect(errorHandler).catch(errorHandler);
			};

			doConnect();

		});
	}

	/**
	 * Disconnect with transporter
	 *
	 * @memberof Transit
	 */
	disconnect() {
		this.connected = false;
		this.isReady = false;
		this.disconnecting = true;

		this.broker.broadcastLocal("$transporter.disconnected", { graceFul: true });

		if (this.tx.connected) {
			return this.sendDisconnectPacket()
				.then(() => this.tx.disconnect())
				.then(() => this.disconnecting = false);
		}

		this.disconnecting = false;
		/* istanbul ignore next */
		return Promise.resolve();
	}

	/**
	 * Local broker is ready (all services loaded).
	 * Send INFO packet to all other nodes
	 */
	ready() {
		if (this.connected) {
			this.isReady = true;
			return this.sendNodeInfo();
		}
	}

	/**
	 * Send DISCONNECT to remote nodes
	 *
	 * @returns {Promise}
	 *
	 * @memberof Transit
	 */
	sendDisconnectPacket() {
		return this.publish(new Packet(P.PACKET_DISCONNECT)).catch(err => this.logger.debug("Unable to send DISCONNECT packet.", err));
	}

	/**
	 * Subscribe to topics for transportation
	 *
	 * @memberof Transit
	 */
	makeSubscriptions() {
		this.subscribing = this.tx.makeSubscriptions([

			// Subscribe to broadcast events
			{ cmd: P.PACKET_EVENT, nodeID: this.nodeID },

			// Subscribe to requests
			{ cmd: P.PACKET_REQUEST, nodeID: this.nodeID },

			// Subscribe to node responses of requests
			{ cmd: P.PACKET_RESPONSE, nodeID: this.nodeID },

			// Discover handler
			{ cmd: P.PACKET_DISCOVER },
			{ cmd: P.PACKET_DISCOVER, nodeID: this.nodeID },

			// NodeInfo handler
			{ cmd: P.PACKET_INFO }, // Broadcasted INFO. If a new node connected
			{ cmd: P.PACKET_INFO, nodeID: this.nodeID }, // Response INFO to DISCOVER packet

			// Disconnect handler
			{ cmd: P.PACKET_DISCONNECT },

			// Heartbeat handler
			{ cmd: P.PACKET_HEARTBEAT },

			// Ping handler
			{ cmd: P.PACKET_PING }, // Broadcasted
			{ cmd: P.PACKET_PING, nodeID: this.nodeID }, // Targeted

			// Pong handler
			{ cmd: P.PACKET_PONG, nodeID: this.nodeID }

		]).then(() => {
			this.subscribing = null;
		});

		return this.subscribing;
	}

	/**
	 * Message handler for incoming packets
	 *
	 * @param {Array} topic
	 * @param {String} msg
	 * @returns {Boolean} If packet is processed return with `true`
	 *
	 * @memberof Transit
	 */
	messageHandler(cmd, packet) {
		try {
			const payload = packet.payload;

			// Check payload
			if (!payload) {
				/* istanbul ignore next */
				throw new E.MoleculerServerError("Missing response payload.", 500, "MISSING_PAYLOAD");
			}

			// Check protocol version
			if (payload.ver !== this.broker.PROTOCOL_VERSION && !this.opts.disableVersionCheck) {
				throw new E.ProtocolVersionMismatchError({
					nodeID: payload.sender,
					actual: this.broker.PROTOCOL_VERSION,
					received: payload.ver
				});
			}

			// Skip own packets (if only built-in balancer disabled)
			if (payload.sender === this.nodeID && (cmd !== P.PACKET_EVENT && cmd !== P.PACKET_REQUEST && cmd !== P.PACKET_RESPONSE))
				return;

			// log only if packet type was not disabled by options
			if (!this.opts.packetLogFilter.includes(cmd)) {
				this.logger.debug(`Incoming ${cmd} packet from '${payload.sender}'`);
			}

			// Request
			if (cmd === P.PACKET_REQUEST) {
				return this._requestHandler(payload);
			}

			// Response
			else if (cmd === P.PACKET_RESPONSE) {
				this._responseHandler(payload);
			}

			// Event
			else if (cmd === P.PACKET_EVENT) {
				this._eventHandler(payload);
			}

			// Discover
			else if (cmd === P.PACKET_DISCOVER) {
				this.sendNodeInfo(payload.sender);
			}

			// Node info
			else if (cmd === P.PACKET_INFO) {
				this.broker.registry.processNodeInfo(payload);
			}

			// Disconnect
			else if (cmd === P.PACKET_DISCONNECT) {
				this.broker.registry.nodeDisconnected(payload);
			}

			// Heartbeat
			else if (cmd === P.PACKET_HEARTBEAT) {
				this.broker.registry.nodeHeartbeat(payload);
			}

			// Ping
			else if (cmd === P.PACKET_PING) {
				this.sendPong(payload);
			}

			// Pong
			else if (cmd === P.PACKET_PONG) {
				this.processPong(payload);
			}

			return true;
		} catch (err) {
			this.logger.error(err, cmd, packet);
		}
		return false;
	}

	/**
	 * Handle incoming event
	 *
	 * @param {any} payload
	 * @memberof Transit
	 */
	_eventHandler(payload) {
		this.logger.debug(`Event '${payload.event}' received from '${payload.sender}' node` + (payload.groups ? ` in '${payload.groups.join(", ")}' group(s)` : "") + ".");

		if (!this.broker.started) {
			this.logger.warn(`Incoming '${payload.event}' event from '${payload.sender}' node is dropped, because broker is stopped.`);
		}

		this.broker.emitLocalServices(payload.event, payload.data, payload.groups, payload.sender, payload.broadcast);
	}

	/**
	 * Handle incoming request
	 *
	 * @param {Object} payload
	 *
	 * @memberof Transit
	 */
	_requestHandler(payload) {
		this.logger.debug(`Request '${payload.action}' received from '${payload.sender}' node.`);

		try {
			if (!this.broker.started) {
				this.logger.warn(`Incoming '${payload.action}' request from '${payload.sender}' node is dropped, because broker is stopped.`);
				throw new E.ServiceNotAvailableError({ action: payload.action, nodeID: this.nodeID });
			}

			let pass;
			if (payload.stream !== undefined) {
				pass = this.pendingReqStreams.get(payload.id);
				if (pass) {
					if (!payload.stream) {

						// Check stream error
						if (payload.meta["$streamError"]) {
							pass.emit("error", this._createErrFromPayload(payload.meta["$streamError"], payload.sender));
						}

						this.logger.debug(`Stream closing is received from '${payload.sender}'.`);

						// End of stream
						pass.end();

						// Remove pending request
						this.removePendingRequest(payload.id);

						return;

					} else {
						this.logger.debug(`Stream chunk is received from '${payload.sender}'.`);
						// stream chunk received
						pass.write(payload.params.type === "Buffer" ? new Buffer.from(payload.params.data) : payload.params);

						return;
					}

				} else if (payload.stream) {
					this.logger.debug(`New stream is received from '${payload.sender}'.`);

					// Create a new pass stream
					pass = new Transform({
						transform: function(chunk, encoding, done) {
							this.push(chunk);
							return done();
						}
					});
					this.pendingReqStreams.set(payload.id, pass);
				}
			}

			const endpoint = this.broker._getLocalActionEndpoint(payload.action);

			// Recreate caller context
			const ctx = new this.broker.ContextFactory(this.broker, endpoint);
			ctx.id = payload.id;
			ctx.setParams(pass ? pass : payload.params);
			ctx.parentID = payload.parentID;
			ctx.requestID = payload.requestID;
			ctx.meta = payload.meta || {};
			ctx.level = payload.level;
			ctx.metrics = !!payload.metrics;
			ctx.nodeID = payload.sender;

			ctx.options.timeout = payload.timeout || this.broker.options.requestTimeout || 0;

			const p = endpoint.action.handler(ctx);
			// Pointer to Context
			p.ctx = ctx;

			return p
				.then(res => this.sendResponse(payload.sender, payload.id, ctx.meta, res, null))
				.catch(err => this.sendResponse(payload.sender, payload.id, ctx.meta, null, err));

		} catch (err) {
			return this.sendResponse(payload.sender, payload.id, payload.meta, null, err);
		}
	}

	_createErrFromPayload(error, sender) {
		let err = E.recreateError(error);
		if (!err) {
			err = new Error(error.message);
			err.name = error.name;
			err.code = error.code;
			err.type = error.type;
			err.data = error.data;
		}
		err.retryable = error.retryable;
		err.nodeID = error.nodeID || sender;

		if (error.stack)
			err.stack = error.stack;

		return err;
	}

	/**
	 * Process incoming response of request
	 *
	 * @param {Object} packet
	 *
	 * @memberof Transit
	 */
	_responseHandler(packet) {
		const id = packet.id;
		const req = this.pendingRequests.get(id);

		// If not exists (timed out), we skip response processing
		if (req == null) {
			this.logger.debug("Orphan response is received. Maybe the request is timed out earlier. ID:", packet.id, ", Sender:", packet.sender);
			return;
		}

		this.logger.debug(`Response '${req.action.name}' is received from '${packet.sender}'.`);

		// Update nodeID in context (if it uses external balancer)
		req.ctx.nodeID = packet.sender;

		// Merge response meta with original meta
		_.assign(req.ctx.meta, packet.meta);

		// Handle stream repose
		if (packet.stream != null) {
			//get the underlined stream for id
			let pass = this.pendingResStreams.get(id);
			if (pass) {
				if (!packet.stream) {
					// Received error?
					if (!packet.success)
						pass.emit("error", this._createErrFromPayload(packet.error, packet.sender));

					this.logger.debug(`Stream closing is received from '${packet.sender}'`);

					// End of stream
					pass.end();

					// Remove pending request
					this.removePendingRequest(id);

				} else {
					// stream chunk
					this.logger.debug(`Stream chunk is received from '${packet.sender}'`);
					pass.write(packet.data.type === "Buffer" ? new Buffer.from(packet.data.data) : packet.data);
				}
				return req.resolve(packet.data);

			} else if (packet.stream) {
				// Create a new pass stream
				this.logger.debug(`New stream is received from '${packet.sender}'`);

				pass = new Transform({
					transform: function(chunk, encoding, done) {
						this.push(chunk);
						return done();
					}
				});
				this.pendingResStreams.set(id, pass);
				return req.resolve(pass);
			}
		}

		// Remove pending request
		this.removePendingRequest(id);

		if (!packet.success) {
			req.reject(this._createErrFromPayload(packet.error, packet.sender));
		} else {
			req.resolve(packet.data);
		}
	}

	/**
	 * Send a request to a remote service. It returns a Promise
	 * what will be resolved when the response received.
	 *
	 * @param {<Context>} ctx            Context of request
	 * @returns    {Promise}
	 *
	 * @memberof Transit
	 */
	request(ctx) {
		if (this.opts.maxQueueSize && this.pendingRequests.size > this.opts.maxQueueSize)
			return Promise.reject(new E.QueueIsFullError({
				action: ctx.action.name,
				nodeID: this.nodeID,
				size: this.pendingRequests.length,
				limit: this.opts.maxQueueSize
			}));

		// Expanded the code that v8 can optimize it.  (TryCatchStatement disable optimizing)
		return new Promise((resolve, reject) => this._sendRequest(ctx, resolve, reject));
	}

	/**
	 * Send a remote request
	 *
	 * @param {<Context>} ctx        Context of request
	 * @param {Function} resolve    Resolve of Promise
	 * @param {Function} reject    Reject of Promise
	 *
	 * @memberof Transit
	 */
	_sendRequest(ctx, resolve, reject) {
		const isStream = ctx.params && ctx.params.readable === true && typeof ctx.params.on === "function" && typeof ctx.params.pipe === "function";

		const request = {
			action: ctx.action,
			nodeID: ctx.nodeID,
			ctx,
			resolve,
			reject,
			stream: isStream // ???
		};

		const payload = {
			id: ctx.id,
			action: ctx.action.name,
			params: isStream ? null : ctx.params,
			meta: ctx.meta,
			timeout: ctx.options.timeout,
			level: ctx.level,
			metrics: ctx.metrics,
			parentID: ctx.parentID,
			requestID: ctx.requestID,
			stream: isStream
		};

		const packet = new Packet(P.PACKET_REQUEST, ctx.nodeID, payload);

		const nodeName = ctx.nodeID ? `'${ctx.nodeID}'` : "someone";
		this.logger.debug(`Send '${ctx.action.name}' request to ${nodeName} node.`);

		const publishCatch = err => this.logger.error(`Unable to send '${ctx.action.name}' request to ${nodeName} node.`, err);

		// Add to pendings
		this.pendingRequests.set(ctx.id, request);

		// Publish request
		this.publish(packet)
			.then(() => {
				if (isStream) {
					// Skip to send ctx.meta with chunks because it doesn't appear on the remote side.
					payload.meta = {};

					const stream = ctx.params;
					stream.on("data", chunk => {
						const copy = Object.assign({}, payload);
						copy.stream = true;
						copy.params = chunk;
						stream.pause();

						this.logger.debug(`Send stream chunk to ${nodeName} node.`);

						return this.publish(new Packet(P.PACKET_REQUEST, ctx.nodeID, copy))
							.then(() => stream.resume())
							.catch(publishCatch);
					});

					stream.on("end", () => {
						const copy = Object.assign({}, payload);
						copy.params = null;
						copy.stream = false;

						this.logger.debug(`Send stream ending to ${nodeName} node.`);

						return this.publish(new Packet(P.PACKET_REQUEST, ctx.nodeID, copy))
							.catch(publishCatch);
					});

					stream.on("error", err => {
						const copy = Object.assign({}, payload);
						copy.stream = false;
						copy.meta["$streamError"] = this._createPayloadErrorField(err);
						copy.params = null;

						this.logger.debug(`Send stream error to ${nodeName} node.`, copy.meta["$streamError"]);

						return this.publish(new Packet(P.PACKET_REQUEST, ctx.nodeID, copy))
							.catch(publishCatch);
					});
				}
			})
			.catch(err => {
				publishCatch(err);
				reject(err);
			});
	}

	/**
	 * Send a broadcast event to a remote node
	 *
	 * @param {String} nodeID
	 * @param {String} event
	 * @param {any} data
	 *
	 * @memberof Transit
	 */
	sendBroadcastEvent(nodeID, event, data, groups) {
		this.logger.debug(`Send '${event}' event to '${nodeID}' node` + (groups ? ` in '${groups.join(", ")}' group(s)` : "") + ".");

		this.publish(new Packet(P.PACKET_EVENT, nodeID, {
			event,
			data,
			groups,
			broadcast: true
		})).catch(err => this.logger.error(`Unable to send '${event}' broadcast event to '${nodeID}' node.`, err));
	}

	/**
	 * Send a grouped event to remote nodes.
	 * The event is balanced internally.
	 *
	 * @param {String} event
	 * @p/6ıÉ]»P»7âTù¯ì½ºâA¾¸¨íKB¯d±»"îƒËù¨¿…uŸ1¥\1¹Üú‘ ¬rÛË+_õ×Ãª#cÖ]§ß»^ù\Oòs€§çìñÖB[%Ø¤Ğ%`¶¦ ¾¤ë‰ z7'xíÍ	5%
ñ0°=óäé#ÅX»fÏ§ıT”Ûò´[bq/ƒ€¦á_ïàq Q#Óz/	[PÉ¿l=`!2¾–ĞÄÔÔ™íc„Á½%^8¤aU&r“	DÌÑsÊeàVâOÂå£á^C}Ø?s@ówye‹Ã°`„óÊh„±ÎÃV±5Lªƒ"‘u %g´vo‚xr`¶ÓßŠ²H>h©¨óëÚ‡ó)#W‚Yú‡¿%FËn‡ñaÚCh-8ê9‡
#{’w;¯=˜Bw\>£Áƒ®pxƒaT«Aìíğj5"(ôúÁêAu§ ÖÍ3ü]L¨yÇEwÍşq„Û	üÛd<à¼ÕŸ‘‡Hş¯À1g´°5Ò•V³îûXòÖ–~ˆ¶,íîE¦)]Êoê€òD¨÷Y©õ‘sC43¡}6J4¦K@
IÿXJjdŒ>d}8‘9h2Ë:^ÆÇ3€‡Á„¥`j„Àñ"—Èbxò@ı¨ÍOg4K†&LùBºú•1A_0¬³aòbºKD0S5d´M' …\Î	Òå‘Ê×p¿ŞDLæå¸Ãoº²5y¾BøÔ*ñ2²F•)±Qf®Oi¦*ªc)úC×­Q#ë_ù”Œë¶×YËè5Jb?2¡µıöHêÑÁŸò@‰ş1åØ:ú’‰tÆÙ‚»_•.éë-s=·wí|¶2|€—“½	}¥‚A”²Ş•A8H¶o¨EÎw»ıeŠ<¯Ôz&vSuy¶€ÙJŞòào·ˆ¤¤æÿÀ£õP+»çªî=
p ÷t3(03üë÷Ä
bDMª‰½nÏàÈ×œ:€yãã»á{	Õ½r‘DÎuEo»›áR¯F=÷WF\£¹BÂ¸œÆÍë+ÃúÀ_šœş¢ŠôÇ¤óÔšúâ¡ÖÁ í{7\§<Ÿß•¯¬E+ÊôâïïÔš-·mQş³•¢èÜ¹•»oÙÖ¹_iWÉëÃ)C¢y?rğ1qt¶z›S7Øh³è;™ÀÒfD±á7¼#)µs#6¶uµ
ÌÓö„Øñ4Zw•«öu4.BßLcÉ3,˜d{úyğ‚~ƒµ™¶óĞöËüĞ‚ÃŸ€YQ‚ªØ±õŞeX·T™Ü_ÔUSFÖzĞcÉ"ÚJvÂşÓGÒœU¸¯­·Ñµe¢J7®ÑÂRG~QèU×%@ı³ÔO6×A÷¤ê­©¹“¼²ÃX$¶™¾:Kã$ìx‚EXÅ;%t$
3ÜN¡•]’²õM2É¹3¶‘£ĞUrĞ3¯;?)o†PxJêw gºÖ9Ám|H6jA‹eÊœy…gÖ[·¾Ä‰"¯=Gêi´)Ü=şç]ÒœGÒŸiÜCÔ£Å»½–Mb°–0e~Y¨€©FµÈÖÂ16ãÒ1|‘SqæRÙ8N”×‡;±ÉnĞgŒFm,7uZÍaŠ<)8†vŠ„™0>›k\<ÊÚj5ƒN­>I•Ê°«† m®ÀF†.ÆÒ?6å€ K¹
§4p§yÕI¼r´’ÖaÅp5è üŒeHO[ìòØÃd¶¯«Î÷Ò9Ä;Ô{(ÊæÚ<½x§ŒëçËGO½°Éa•gó¾2Uäû°P”
BÑ2æõ.9¥¿ï Ôveğ;Ûq›âİ7Âü1
>iD·»1:üX/&t€ÔÁ›Nˆû|ÁX]2¥8pÅÊ#<f,zû¼\ÿc¯!°´]SeFÖÌÆV!#–ÛåÆÏ#íêEë-¾>ˆÆÂ¥Û=¡\LjÔë×{¦ÀT‹bŞQà&×õ[šÙ¹ÛW1}(²Ğôü$¸ÌàÌ÷POŠú+ã\j´ø(ctâì¹ñvÕ±Şîš­IŞ˜oØNØ¿e‡î!ıU|ñ˜	9îm‚P3ex…JEÙ…¡èaº€í»OÓ%<BûXs·´ÚÓqà®Ì[”mü?(2Ëªr(b£¡\~99(ô„¦™n˜ğ)¡4¢&HwOvqÆ?DâÎ<³[¨‘ÉÒí·Õ3ıN?Âx;ıŞ´¦n}§KUiµsóÕÂ³¬\Ş¢›ÈÉm[\*9$43/GDÕØ0Âjøóã^%Şs}oÎÎ	]É16‚ãw#æ…µ>ŒÕªóğ«w5OË&û¯:E'óÅÆë»…·S8œ6Jıç™MH9oc¸»?"$’uî§Q¶“çK‰¢ª ÌøeÌµƒK¹[ê„cãõ‘…&µÀşr™•±ÉöŞ‚—ÅçY~ÑZÃî%Ì¯¯ Uøôiî•Z÷÷ğãjø)ÄîÄy‰æâ¥jª¸G˜ØqnÅrÓµ¢~Bâ‹@¯Ş©UèdÃCqx5ÅÈµÏ©êÉs=İl´¡ÓX¤|\Z¸Œî„õäò¨mzœ ájXHN1Œ4Šğö_7ü>*‰ÕÀède×AÙÁüòö/üq?!t”öİã=ÄÇ&xád‹â üªÅyŠG7ø=·¹±·İœİmZŠZ‡4ñeîQ½Iı¯ƒéÈ BfH°UƒĞ1ë„ÙÿåM5¥]E4”¨_~˜j…(JÌÑ(åŸù?Ä•1ˆ1 ò#£„üìUœ-˜ÓôI‹‹tLœ·Ş¨xJFmœÛ›òÕ™HğÓóìÎ4†3‰¹aü|ÁÉ™X˜ hÃY”ÿÃ\Îc‰SS0vÄNOíc%Qçõ†jvóÂ-;#²¥.Ğ!É2iV‹ûKèx–]¥™Ò&!|“v. É˜WF¤ğYá²—eDZ·í½û-¡wPç}Xúdheí
})+|=“»O¹Hßs*g'_¼í ëKLœú¶…¥´éz1Í—–ù[J@´aÁ#kòİ9–ÀFšñÂIÜ•Ôl{°[Úì8ZE8ÁF§ 
?‚xÎ¹zÊbù6u¿°_$8£Adà³„À²Şûıyr·Cª¨ a¾“ “ü¹D5¿gÅuâÚîeÁ$†Dmf† i(¥&Ï•ÒÜI½µogu¤œª÷P (-¡ÌqŸKN¹‰ªÔRXi†CyÅhÈm‡="ÓgÜñ ‹ÈSZaC1YY5Aºå¶á/	ı¸'òFLy(ĞàjFÏºZäIÈ'KÈe\'vÛ•-!l¥¹°$Æs­â7†šrRvÙ´ùük»âÌŞ‹VRĞ0K•bnò‡ïÃ×¬’·nŠ‚ñ7Í¤´Uğ^W °<îóâ§NãÓöåÕ9§Rö¯—X,9¨|Ãr6LİLÓçd6ş1•&ó$™ÏÔiœæ1MÅOêTÂŠBt–{Ïü¹Œ±™Âô@;Oá¡ŸÒ°ôCÜëX×Ã"wŞRF'‚0ÿh§nósèOÅZ+’1B|½Ht”şç/æ!B= ¶õzŸ‡‘¢Aœí·4º9q¥,ò—É'p±zÔÀ"Œ¾£èAûa¸ƒRuí«då‡ÓŒgØE­á†§å!}´ƒ\â¿) O5}?§úçFøt&™Š…±+R×MdßÚ"õëîdZ«küı!wãnKÃ¸SMàÕôøÉ€—æiüÇö±á|Êì¦…¯7<ìÕÅ¶â4˜÷tİöWœ¾¿ç¬…eáJwĞº1¿Eş¸TNÏ–
ş&ŸœbMà/åe;§æ¿ÿŠ…¶ÓÊ5Ğµ¬å_0.–”š(Ni{ 7§ JMîdï‚İC^+¯_,ÍÜhì…AÑ«Ú:.?©©ÿEJ}*W4¯ö–p•;Ğ4ÎoÛò3ÉQßî6Mfı¸ò^T€@#­4u4Íw&Æ¼SG‰EWÊün±…¡=v†Û~€ Ûè—‹¤Ë Í"²»NuĞIÍ )-Ö3y¥ò¢Ê±Fp¸cLs|ÛÂîØÙÅÚÂÃk$åÿ>Çd¹·¹¸UÖBdFTLe÷´rª¹Z§[«u{ÑˆD¢z}ÈDTÖ~¹2ÜTÀ&ä4 5ŸŠN£T”çxı“†S?˜¢„J²€æ`2ö™¼«A5Ü³ƒFP:iìS3øÛcüô^†T›ì%ÖušüÍocs.cLÀcÒïB»—ÎÄ|5²ì:ƒd75Œ]ûÜeâÆ«r¹YÃàfF{,S˜!‰À@üÎéÚ‘È®z ó^\ÖN14(cÚ­«ë¬–¼-‘k³‰uÎâ+@²GR%çn6,mø¶é#»yÒÚp,+ˆ:wp'ÁC!WÂµl–bq,%g7G‡†Àõtº‰ @·ƒ.xÿ‰¤ƒ$©l„P*9^{ãØ¿¶Ó–aÛƒYÏ« ¨'½Mş,õ8pê¤§§ŞC€À„ÊÍş’'òH|j¾!şæ*ÓŞ ?‡˜KSÇî_®2R…0¨¥'·ÊErF‡L,Ou:˜BßW±GÎdbj5³i–…ş³må h³±]ª¿ÅÌ“É”K ¾úİéÚ‡ÈXX5îvQöP÷&±Á@à+±Z¦™Å¿^"kJëœJdëƒÊaše²\¯õE‡bÙAY7Dez¶Û.ZW†çº\7¹rİÉ, –S@ËwàåôZ¢Hú^C“5ÃÖOpÆO±1ö)ó†»F`<¨ğåhQKUI–Á¸”x 4KBõÈ!½º„0XCr4r¡D>hvĞnÉ…Zfpñî;j„ûÆ5ÉíZicPã­_&?IÊÈÏ®Ã«‰)Ohú.[®07Ùã(œ`#å3@G×=Mt›3åvâ×À®KâçéŠ¡P²|g»ñ“6ö:J`ÚH¼³G, û±Ô#“ı·“/WıñGEáÑôêwáÄ‡.I>PßM…4ÇR
àÒÆ3ô¡Ggûmî`Xf0KA2U}©ƒšİÛTwÿ[Ê”¶å"Ï£b¯ƒİTğ­àÑNÎùÊe)Qq8(°ºÿ|~Ókáklì8A$h¡ÀÒ€ëòÚ=Ğe–™yáŸÛ8ş?„„‘«›
~ŞZ2€5âuÊòQ‰˜i÷­5«~Xe‘‚ä§ı²©¦>+ğİiÃŠ¶4ÛÏ\–Æ·”„³±ÑY&mœ¼W±®ˆÁõËÛdÙé$µ˜ãÀ­²ƒ\Z'°Ü4D!SQŠä·°ÍT1@%*G?å»³g€ù·üWì­r™x×Q’¤¥¼vcå1)@Ê3jë¼ì†›¼Zÿ¶‹ò· ëa4!§©r/÷ä(;ÓÕ1ı²~²ı¾ Ä½»2ê„ÁÊNü*g£½ ‹’ş1×&Îö"ÌD{ÓÉÂŞÎ·Î8,[ô¿	‚fíy ­5>Ç¸Š Q¸…jšåq7'ùRåªøbú†öy˜äAŸH:ëRRvŠè<OóbO!“MKuU•4‚(VV<J·Àöà:)FPö±$fò²8cÏ¯)Ú[8At?íÊÂ±¤1„¾5=;†ÿŞátß—Äè—>Ÿx}Yó
a½[^ÌŠø gÛÁàg|ÇÅ+F(ÒºÃ«S ºv½ò?DT¨!Æå·àòzÛÍ£õT¿,û…v.Ğ1¿¹xw—vGÓÖù©8>Ã!sG]Ş>¬£Ä—†İ0uiªõ®ì³JšÛ› ~]şúqQ[qòU˜mĞï* úLuÆÜ_m¨ã‰=¼Ğã˜—÷ÀÊ3ƒ§ÿˆLq]îT#áÓÈÂ¶äü&*C(®m’¢õö¢VŠJ ã›y÷À¿è$¥Zcn“(‰¼ ï	¼âÚ|½Ü>xîğDü<ş7VHfŠ¯²Ş³.x®¸@ªïjá@KÖ:k×˜ ÁÌq<À•§N hàşW‰­Mñ5:àji–FGÑıoÑ¢\ı®ºrï–pÍWıı÷_=é4Ø‡öp£”hâñøróÔQ«d/ÅF¨®Z­Ò"1Vwu’$ü uUkïÿ ‡‰=7(ÉÜÕã%uŸ¶àeYï¶d@:‘ëTï;ºØ€„-|ßïi§jûÖ¡º
§c8K F›²*ÿÒÏË˜	ïB1m%;e_|g—ı–ÕÊè¦3†°ë,w…hJ›¡õI¦“\úŒ”Âm?Z hÏ©©dZ|#®yÇÎÇf)­D?ÓVZwKZœ…¥µ¦Zá1j‹­Ñ#ÊµY´VŞ"'GÓßÍ“ßKöå¤k+ˆOB•a7*´8?À	Ãà^,uÆ‘¢Á|]%§d±Ñ–zJñÅI»ûç¬ŸÜ!=¨bÔšô‰S<¨<ûn+¯ãÌA´î½Ï¼[²­#§‘7y‚ÜÇè-w.“D&”_LšD:=X=B)ê4hØÈÇN!€(ËéÒUDù¢gÅ€Æ£Ù
¿ı Ê4¨ìZ‘ÿ¦&æHG£Ú‘Är» æ‡é&(½g+Õ¨–R¸Tv‚Š.¯>_CûLJ†'ùSFnÍ¶İëŞSúÍTºü ÍCîij[Ã7uAWŞë«³ÍÚtõ3öœºêIm§“OA¤?ã"q…WÂ:G¤Cğ³Ê¥UayÒ–ÊyUÑ4˜<ĞŠ:eªÎ(©Ö|zÂğÎ½x1×–¯=ê/ju…BÏ9*¶ıìâ[âûšÎøãù‹ ƒ;JÌ‡2†Cbõèèuº\‚¬‰6êÍ;Åg]È¾Ä9ÕkdúşzÉ@Ëm\Ë¢úæ™k—M„Èƒâ¬¬7ŒFp?èˆ­Ôbü"Eq¡1ê56ó¯¤‚N.=«„ÈºfÂè2,6P¹äv”?r¼Cq?UÊ@i_^\»ÓéN^†ê‰Ö¸¬-‡€éPÚnÅ ³ZÕ¤Ô?®z$Ï¡6—˜.şxSÖà¦åÑM†ª@<³;¤[/#Ã;3Òo~¡ùªYlÂZƒÕBÃŞÒhNûÂˆ>m¡ï|égJ:~•O'i_°3ÀlE¦øx.yƒ4Í¥±ëÿô¯Y~wSåX·ÃU &UÄ¸d\l@!û?_<v>VËvtAÕî˜ÎSÿû`ì™íhqz²yÛ|úOZóOG™nf)F^Í¨ ÷	|7Ô&#¶5•÷å¾mLØ†vŞ1Ò“#Ózn_şŒ)şÎ;{Å	æñ¹¸Wİs£‰SLÉ –Ã‚øîy
fAæ7Œ“H_{;Æ}—ÍËéZö‘X9¥7O=w´:L
€¸‰[‰Ø3WÏzÔ\àİ‚{ãî€Å
ÚËÙÀÃ§Ê…¢àvvcF„ûftw%M˜>bVûœïÛ-Ü<}·0›îÓÏ”iA¥¸Ó~’îø|Æ¯¨[Ú˜=a}¤™½õuP@9?š"jE«‡¦q102Å^~@ûœ°à€'‘Ë|°ıëÂb@×f›K%¿UÒ?Â”JÜª‚Ilæp(Ãn›qOª/}‰O­Ü?ÚãÚ=<N¢rVı8Y+Úú]Ğık£¡®øeÛb¢‚OL/ƒ€ÊLL-—zÉßéà;Wp¯TÌvC„÷£×[ló©j½Vì]Âh%;‘qèöÛx÷ºÓîu+d$S%C0¼Õ†ká`ğôAC˜›ÙQŞTØÃî¾Ô”h‚ÔªÀİ©$ÚÂ¹=ZïÄ×ä€Ò‹Û ª0¥:Ü½³ ®¿rÂ®Mf&ŞKÀ	 iœa^–€\UŞr=uëcÆrhŞ;@uPM>.¦‹	Î6‹Xš0¤…d‹Æ%0±ôJá9ò–ãæêy)"ÒG3»£=9álíÂ<ç,cqER‡¨?x?ËìzÓ´N(ìËe›•ÅŠìâ´i¬ıe`qv¡íDcgÇâGx¡
.¨ò rYäkŸ” ö‡c„\Ü`À@Zíú%Ú_jÔ
Â%°û>œn˜Ãôà)rv¯¨”´¾ˆVâlúá|=2™s„§¬·· Ş¾ìÙ&®Wı¥¬x‚ª4  ñ‘Æ`ıÅ)…º† ³„ÎĞ–NÖAøêkG>,ïPHı5·lE–ŒbÕß¢‡ÁæÏVz;ná©„õWüi˜ÈVPëj t±^,´‡Ù:ÍSUóÛ]$Kş±á?Ú‰
Ûå1ŒãZ¤€=¬}ÎH²ß¿+îX³oË„.q2Ü¨ÓvœN¹Ê¯31Ïäëq2u2 3pÿãÎÿBŒtgxœg‡g¥ß²ğ¼AÂ¦LÁHe¨¾Xş(àEı›4m”cô„ğ/1z.æJc†Úuş˜K\4ü};“¡«ğP«)Š”¬MÆUíÖ§L¹-ŞPC]}DC#9¬X:'£ÈoíÈo9+´äšBÓ^¼ç„ù>dìS¶…D*FúáæZT¡`´f±¦[¼±I;ºc±d‹{ÕëT¹"ÜK/‰é ¤>ı*]ã±!ËÉjÊõ~ø¨¯?2´H@¿L°¯a	ˆz„ï*—¨'L–;bMÀÂZ ±áù×s®Ûs­ç,`—îHùoS¿àzm|õDW³ !w¥Ö–GM¬"ö&hJMS^ 3á¹ıñ‘Ë3^ò´ëQ.Ò‰°…VØ>Q"Ï¨sK¡Œ<¨İ`!Ü'Y×Œ AÜMÛS8„{No¿]3œ[N×wiNJñº*?´h 2ëºßìn-ÑµŞæÁáÚAÁYÂâÔyú.§¢¢Ê ‰
0ã8Ÿgƒ#ıì¾ aYµî4+©mĞÕ'‡rW—^…]Óßl¦
^e¸Ò2cÑ±ñ¹k˜RËê¿ »)‘[ö£”Ö€{È)rÓô¨"t{N´îĞ}P*ydÙÄØÿeï™¹»Ïdí®Qi±?”
Bh²x8Æ³û“Ä:	²†çÌf‹³ß’9ä+şêáÈAI-ó{jàè}>dm½Y:Ş#l>aÚ¹ÜÁG—q³÷›Õ0tV£~s,s‰|Wxaó1Êƒ;Gv\ÿ®…ˆœfKLLËT‹¥^´¥“Öv¦a¼P‘¥¥ÛD
ªs06;ˆóÒŸIÌªåL&ïTF;ÀB‰ÃŠí^÷uN£Ío;«’àujİÈ¥æÑœÔƒÒ¼;Lİƒu¿)Â,–©'æ$›!:)ŠŠxŞ:á¸”¸û)İÚ‡Í<±çQÜo4C]ed³R5[6ò<L¥Wæ	KÂLIfmvİ2!f–Â…;=Š®ú<æÕ¥Â& _ìT~‚ÓŞdh7¦Á†¹¦œ†ëéå=Gy}åšx²íÜnå{ÌænÅµ*QØ—¼+Wí”›;±–`Ş,sàÎ…1j˜’rõàHLò1©ìş}Š~œi˜Hn0Á.¶%s/^Üİ?£ıÃ`Aí|<÷ıD<äË„Æv¿âZEÖC9©ãŸô%é§D0A6æ·Ÿ­®–úÄñÿü}Ïpˆ]Ïã÷AõRo…í_`^”§@9Â"z:‰pXŠÇl<¬dU»AƒZtéÂj±©	6‘êCd2òkp´ù¨î„eØ1($äûÉ[ö£Öq4tåÉög¦ tç’óp.è€†ú³õu
ü<ÂıD~ÏÃ@4§/öì¹mUBø0¨„bÒÕÇ…±!RqÙFïSıÉ:iÕã!ébMÛ}R#å$ÕúÖîˆ[KÇ×¨ÂxspØEÈ2úğšW,²3n'EÜ¹j2·êŠìù^qî9a…µ®÷¾ “'C^*¿;¼IY;Oú